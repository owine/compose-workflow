name: Deploy Docker Compose

on:
  workflow_call:
    inputs:
      args:
        description: "docker compose up -d arguments"
        required: false
        type: string
      stacks:
        description: "JSON array of stack names to deploy"
        required: true
        type: string
      webhook-url:
        description: "1Password reference to Discord webhook URL"
        required: true
        type: string
      repo-name:
        description: "Repository display name for notifications"
        required: true
        type: string
      target-ref:
        description: "Git reference to checkout on remote server"
        required: true
        type: string
      has-dockge:
        description: "Whether this deployment includes Dockge"
        required: false
        type: boolean
        default: false
      force-deploy:
        description: "Force deployment even if repository is already at target commit"
        required: false
        type: boolean
        default: false

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    timeout-minutes: 40
    outputs:
      previous_sha: ${{ steps.backup.outputs.previous_sha }}
      deployment_needed: ${{ steps.backup.outputs.deployment_needed }}
      deploy_status: ${{ steps.deploy.outcome }}
      health_status: ${{ steps.health.outcome }}
      cleanup_status: ${{ steps.cleanup.outcome }}
      rollback_status: ${{ steps.rollback.outcome }}
      healthy_stacks: ${{ steps.health.outputs.healthy_stacks }}
      degraded_stacks: ${{ steps.health.outputs.degraded_stacks }}
      failed_stacks: ${{ steps.health.outputs.failed_stacks }}
      total_containers: ${{ steps.health.outputs.total_containers }}
      running_containers: ${{ steps.health.outputs.running_containers }}
      success_rate: ${{ steps.health.outputs.success_rate }}
    steps:
      - name: Configure 1Password Service Account
        uses: 1password/load-secrets-action/configure@581a835fb51b8e7ec56b71cf2ffddd7e68bb25e0  # v2.0.0
        with:
          service-account-token: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}

      - name: Load Tailscale credentials
        id: load-tailscale-credentials
        uses: 1password/load-secrets-action@581a835fb51b8e7ec56b71cf2ffddd7e68bb25e0  # v2.0.0
        with:
          export-env: false
          unset-previous: true
        env:
          TAILSCALE_OAUTH_CLIENT_ID: "op://Docker/tailscale-oauth/client_id"
          TAILSCALE_OAUTH_SECRET: "op://Docker/tailscale-oauth/secret"

      - name: Connect to Tailnet
        uses: tailscale/github-action@84a3f23bb4d843bcf4da6cf824ec1be473daf4de  # v3.2.3
        with:
          oauth-client-id: ${{ steps.load-tailscale-credentials.outputs.TAILSCALE_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ steps.load-tailscale-credentials.outputs.TAILSCALE_OAUTH_SECRET }}
          tags: tag:ci
          use-cache: true
          version: latest

      - name: Unload Tailscale credentials
        uses: 1password/load-secrets-action@581a835fb51b8e7ec56b71cf2ffddd7e68bb25e0  # v2.0.0
        with:
          unset-previous: true

      - name: Store current deployment for rollback
        id: backup
        run: |
          echo "::group::Preparing deployment backup"
          CURRENT_SHA=$(ssh -o 'StrictHostKeyChecking no' ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} 'cd /opt/compose && git rev-parse HEAD')
          TARGET_SHA="${{ inputs.target-ref }}"
          
          echo "Current deployed SHA: $CURRENT_SHA"
          echo "New deployment SHA: $TARGET_SHA"
          echo "previous_sha=$CURRENT_SHA" >> $GITHUB_OUTPUT
          
          if [ "$CURRENT_SHA" = "$TARGET_SHA" ] && [ "${{ inputs.force-deploy }}" != "true" ]; then
            echo "‚ö†Ô∏è Repository is already at target commit - no deployment needed"
            echo "deployment_needed=false" >> $GITHUB_OUTPUT
          elif [ "$CURRENT_SHA" = "$TARGET_SHA" ] && [ "${{ inputs.force-deploy }}" = "true" ]; then
            echo "üîÑ Force deployment requested - proceeding despite same commit"
            echo "deployment_needed=true" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ Deployment needed - proceeding with update"
            echo "deployment_needed=true" >> $GITHUB_OUTPUT
          fi
          echo "::endgroup::"

      - name: Deploy All Stacks
        id: deploy
        if: steps.backup.outputs.deployment_needed == 'true'
        continue-on-error: true
        run: |
          echo "::group::Deploying all stacks"

          # Parse stacks from JSON input
          STACKS="${{ join(fromJson(inputs.stacks), ' ') }}"

          ssh -o "StrictHostKeyChecking no" ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} "
            set -e
            export OP_SERVICE_ACCOUNT_TOKEN=${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}

            if [ \"${{ inputs.has-dockge }}\" = \"true\" ]; then
              echo \"üöÄ Deploying Dockge...\"
              cd /opt/dockge
              op run --env-file=/opt/compose/compose.env -- docker compose pull
              op run --env-file=/opt/compose/compose.env -- docker compose up -d --remove-orphans ${{ inputs.args || '' }}
              echo \"‚úÖ Dockge deployed successfully\"
            fi

            echo \"Updating repository to ${{ inputs.target-ref }}...\"
            git -C /opt/compose/ fetch
            git -C /opt/compose/ checkout ${{ inputs.target-ref }}

            # Function to deploy a single stack
            deploy_stack() {
              local STACK=\$1
              local LOGFILE=\"/tmp/deploy_\${STACK}.log\"
              {
                echo \"üöÄ Deploying \$STACK...\"
                cd /opt/compose/\$STACK

                echo \"  Pulling images for \$STACK...\"
                if ! op run --env-file=/opt/compose/compose.env -- docker compose pull; then
                  echo \"‚ùå Failed to pull images for \$STACK\"
                  return 1
                fi

                echo \"  Starting services for \$STACK...\"
                if ! op run --env-file=/opt/compose/compose.env -- docker compose up -d --remove-orphans ${{ inputs.args || '' }}; then
                  echo \"‚ùå Failed to start services for \$STACK\"
                  return 1
                fi

                echo \"‚úÖ \$STACK deployed successfully\"
                return 0
              } > \"\$LOGFILE\" 2>&1

              return \$?
            }

            # Start all deployments in parallel
            echo \"üöÄ Starting parallel deployment of all stacks...\"
            PIDS=\"\"

            # Deploy each stack in parallel
            for STACK in \$STACKS; do
              deploy_stack \"\$STACK\" &
              PIDS=\"\$PIDS \$!\"
              echo \"Started deployment of \$STACK (PID: \$!)\"
            done

            # Wait for all deployments and collect results
            echo \"‚è≥ Waiting for all deployments to complete...\"
            FAILED_STACKS=\"\"

            # Wait for all background jobs
            wait

            # Check deployment results from log files
            for STACK in \$STACKS; do
              if [ -f \"/tmp/deploy_\${STACK}.log\" ]; then
                if grep -q \"‚ùå.*\$STACK\" \"/tmp/deploy_\${STACK}.log\"; then
                  FAILED_STACKS=\"\$FAILED_STACKS \$STACK\"
                fi
              fi
            done

            # Display all deployment logs
            echo \"üìã Deployment Results:\"
            for STACK in \$STACKS; do
              if [ -f \"/tmp/deploy_\${STACK}.log\" ]; then
                echo \"--- \$STACK ---\"
                cat \"/tmp/deploy_\${STACK}.log\"
                rm -f \"/tmp/deploy_\${STACK}.log\"
              fi
            done

            # Check if any deployments failed
            if [ -n \"\$FAILED_STACKS\" ]; then
              echo \"üí• Deployments failed for:\$FAILED_STACKS\"
              exit 1
            fi

            echo \"üéâ All stacks deployed successfully in parallel!\"
          "
          echo "::endgroup::"

      - name: Health Check All Services
        id: health
        if: steps.backup.outputs.deployment_needed == 'true' && steps.deploy.outcome == 'success'
        continue-on-error: true
        run: |
          echo "::group::Health checking all services"
          
          # Parse inputs outside SSH context
          STACKS="${{ join(fromJSON(inputs.stacks), ' ') }}"
          OP_TOKEN="${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}"
          HAS_DOCKGE="${{ inputs.has-dockge }}"

          ssh -o "StrictHostKeyChecking no" ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} << EOF | tee /tmp/health_output.log
            set -e
            export OP_SERVICE_ACCOUNT_TOKEN="$OP_TOKEN"
            
            # Set stacks variable
            STACKS="$STACKS"

            echo "‚è≥ Waiting for services to stabilize..."
            sleep 15

            FAILED_STACKS=""
            DEGRADED_STACKS=""
            HEALTHY_STACKS=""
            TOTAL_CONTAINERS=0
            RUNNING_CONTAINERS=0

            if [ "$HAS_DOCKGE" = "true" ]; then
              echo "üîç Health checking Dockge..."
              cd /opt/dockge
              DOCKGE_RUNNING=\$(op run --env-file=/opt/compose/compose.env -- docker compose ps --services --filter "status=running" | wc -l | tr -d " ")
              DOCKGE_TOTAL=\$(op run --env-file=/opt/compose/compose.env -- docker compose ps --services | wc -l | tr -d " ")
              TOTAL_CONTAINERS=\$((TOTAL_CONTAINERS + DOCKGE_TOTAL))
              RUNNING_CONTAINERS=\$((RUNNING_CONTAINERS + DOCKGE_RUNNING))
              
              if [ "\$DOCKGE_RUNNING" -eq 0 ]; then
                echo "‚ùå Dockge: 0/\$DOCKGE_TOTAL services running"
                FAILED_STACKS="\$FAILED_STACKS dockge"
              elif [ "\$DOCKGE_RUNNING" -lt "\$DOCKGE_TOTAL" ]; then
                echo "‚ö†Ô∏è Dockge: \$DOCKGE_RUNNING/\$DOCKGE_TOTAL services running (degraded)"
                DEGRADED_STACKS="\$DEGRADED_STACKS dockge"
              else
                echo "‚úÖ Dockge: All \$DOCKGE_RUNNING services healthy"
                HEALTHY_STACKS="\$HEALTHY_STACKS dockge"
              fi
            fi

            # Function to perform comprehensive health check on a stack
            health_check_stack() {
              local STACK=\$1
              local LOGFILE=\"/tmp/health_\${STACK}.log\"
              {
                echo \"üîç Health checking \$STACK...\"
                cd /opt/compose/\$STACK

                # Get container status information
                SERVICES_INFO=\$(op run --env-file=/opt/compose/compose.env -- docker compose ps --format json 2>/dev/null || echo '[]')
                RUNNING_COUNT=\$(echo \"\$SERVICES_INFO\" | jq -r 'length')
                TOTAL_COUNT=\$(op run --env-file=/opt/compose/compose.env -- docker compose config --services | wc -l | tr -d \" \")
                
                # Count healthy vs unhealthy containers
                HEALTHY_COUNT=\$(echo \"\$SERVICES_INFO\" | jq -r '[.[] | select(.State == \"running\")] | length' 2>/dev/null || echo \"0\")
                EXITED_COUNT=\$(echo \"\$SERVICES_INFO\" | jq -r '[.[] | select(.State == \"exited\")] | length' 2>/dev/null || echo \"0\")
                
                # Check for restart loops (containers that have restarted recently)
                RESTART_ISSUES=\$(echo \"\$SERVICES_INFO\" | jq -r '[.[] | select(.State == \"running\" and (.Status | contains(\"Restarting\")))] | length' 2>/dev/null || echo \"0\")

                # Resource usage check
                if [ \"\$HEALTHY_COUNT\" -gt 0 ]; then
                  CONTAINER_NAMES=\$(echo \"\$SERVICES_INFO\" | jq -r '.[] | select(.State == \"running\") | .Name' 2>/dev/null | tr '\n' ' ')
                  if [ -n \"\$CONTAINER_NAMES\" ]; then
                    RESOURCE_INFO=\$(docker stats --no-stream --format \"{{.Name}}: CPU {{.CPUPerc}}, Mem {{.MemUsage}}\" \$CONTAINER_NAMES 2>/dev/null | head -3)
                  fi
                fi

                # Determine stack health status
                if [ \"\$HEALTHY_COUNT\" -eq 0 ]; then
                  echo \"‚ùå \$STACK: No services running (\$EXITED_COUNT exited)\"
                  [ -n \"\$RESOURCE_INFO\" ] && echo \"   Resources: \$RESOURCE_INFO\"
                  return 1
                elif [ \"\$HEALTHY_COUNT\" -lt \"\$TOTAL_COUNT\" ]; then
                  echo \"‚ö†Ô∏è  \$STACK: \$HEALTHY_COUNT/\$TOTAL_COUNT services running\"
                  [ \"\$EXITED_COUNT\" -gt 0 ] && echo \"   \$EXITED_COUNT services exited\"
                  [ \"\$RESTART_ISSUES\" -gt 0 ] && echo \"   ‚ö†Ô∏è \$RESTART_ISSUES services restarting\"
                  [ -n \"\$RESOURCE_INFO\" ] && echo \"   Resources: \$RESOURCE_INFO\"
                  return 2  # Degraded state
                else
                  echo \"‚úÖ \$STACK: All \$HEALTHY_COUNT services healthy\"
                  [ \"\$RESTART_ISSUES\" -gt 0 ] && echo \"   ‚ö†Ô∏è \$RESTART_ISSUES services had recent restarts\"
                  [ -n \"\$RESOURCE_INFO\" ] && echo \"   Resources: \$RESOURCE_INFO\"
                  return 0
                fi
              } > \"\$LOGFILE\" 2>&1

              return \$?
            }

            # Health check each stack sequentially for reliability
            echo \"üîç Starting comprehensive health checks...\"
            for STACK in \$STACKS; do
              echo \"Starting health check for \$STACK...\"
              if health_check_stack \"\$STACK\"; then
                EXIT_CODE=\$?
                case \$EXIT_CODE in
                  0) HEALTHY_STACKS=\"\$HEALTHY_STACKS \$STACK\" ;;
                  2) DEGRADED_STACKS=\"\$DEGRADED_STACKS \$STACK\" ;;
                  *) FAILED_STACKS=\"\$FAILED_STACKS \$STACK\" ;;
                esac
              else
                EXIT_CODE=\$?
                if [ \$EXIT_CODE -eq 2 ]; then
                  DEGRADED_STACKS=\"\$DEGRADED_STACKS \$STACK\"
                else
                  FAILED_STACKS=\"\$FAILED_STACKS \$STACK\"
                fi
              fi
            done

            # Calculate container statistics
            for STACK in \$STACKS; do
              if [ -f \"/tmp/health_\${STACK}.log\" ]; then
                STACK_CONTAINERS=\$(cd /opt/compose/\$STACK && op run --env-file=/opt/compose/compose.env -- docker compose config --services | wc -l | tr -d \" \")
                STACK_RUNNING=\$(cd /opt/compose/\$STACK && op run --env-file=/opt/compose/compose.env -- docker compose ps --services --filter \"status=running\" 2>/dev/null | wc -l | tr -d \" \" || echo \"0\")
                TOTAL_CONTAINERS=\$((TOTAL_CONTAINERS + STACK_CONTAINERS))
                RUNNING_CONTAINERS=\$((RUNNING_CONTAINERS + STACK_RUNNING))
              fi
            done

            # Display comprehensive health check results
            echo \"\"
            echo \"üìä Health Check Summary:\"
            echo \"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\"
            echo \"Total Services: \$TOTAL_CONTAINERS\"
            echo \"Running Services: \$RUNNING_CONTAINERS\"
            echo \"Success Rate: \$(( RUNNING_CONTAINERS * 100 / TOTAL_CONTAINERS ))%\"
            echo \"\"

            # Display results by category
            [ -n \"\$HEALTHY_STACKS\" ] && echo \"‚úÖ Healthy Stacks: \$(echo \$HEALTHY_STACKS | tr ' ' ',' | sed 's/^,//')\"
            [ -n \"\$DEGRADED_STACKS\" ] && echo \"‚ö†Ô∏è Degraded Stacks: \$(echo \$DEGRADED_STACKS | tr ' ' ',' | sed 's/^,//')\"
            [ -n \"\$FAILED_STACKS\" ] && echo \"‚ùå Failed Stacks: \$(echo \$FAILED_STACKS | tr ' ' ',' | sed 's/^,//')\"

            echo \"\"
            echo \"üìã Detailed Results:\"
            echo \"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\"
            for STACK in \$(echo \"\$STACKS\" | tr ' ' '\n' | sort); do
              if [ -f \"/tmp/health_\${STACK}.log\" ]; then
                cat \"/tmp/health_\${STACK}.log\"
                rm -f \"/tmp/health_\${STACK}.log\"
              fi
            done

            # Export variables for output capture
            echo "HEALTH_OUTPUT_HEALTHY=\$(echo \$HEALTHY_STACKS | tr ' ' ',' | sed 's/^,//')"
            echo "HEALTH_OUTPUT_DEGRADED=\$(echo \$DEGRADED_STACKS | tr ' ' ',' | sed 's/^,//')"
            echo "HEALTH_OUTPUT_FAILED=\$(echo \$FAILED_STACKS | tr ' ' ',' | sed 's/^,//')"
            echo "HEALTH_OUTPUT_TOTAL=\$TOTAL_CONTAINERS"
            echo "HEALTH_OUTPUT_RUNNING=\$RUNNING_CONTAINERS"
            echo "HEALTH_OUTPUT_SUCCESS_RATE=\$(( RUNNING_CONTAINERS * 100 / TOTAL_CONTAINERS ))"

            # Determine final health status
            if [ -n "\$FAILED_STACKS" ]; then
              echo ""
              echo "üí• Health check failed - some stacks are not running"
              exit 1
            elif [ -n "\$DEGRADED_STACKS" ]; then
              echo ""
              echo "‚ö†Ô∏è Health check passed with warnings - some services degraded"
              exit 0
            else
              echo ""
              echo "üéâ All services are fully healthy!"
              exit 0
            fi
          EOF
          
          # Extract health outputs for Discord notifications
          if grep -q "HEALTH_OUTPUT_" /tmp/health_output.log 2>/dev/null; then
            grep "HEALTH_OUTPUT_HEALTHY=" /tmp/health_output.log | cut -d'=' -f2 | head -1 | xargs -I {} echo "healthy_stacks={}" >> $GITHUB_OUTPUT
            grep "HEALTH_OUTPUT_DEGRADED=" /tmp/health_output.log | cut -d'=' -f2 | head -1 | xargs -I {} echo "degraded_stacks={}" >> $GITHUB_OUTPUT
            grep "HEALTH_OUTPUT_FAILED=" /tmp/health_output.log | cut -d'=' -f2 | head -1 | xargs -I {} echo "failed_stacks={}" >> $GITHUB_OUTPUT
            grep "HEALTH_OUTPUT_TOTAL=" /tmp/health_output.log | cut -d'=' -f2 | head -1 | xargs -I {} echo "total_containers={}" >> $GITHUB_OUTPUT
            grep "HEALTH_OUTPUT_RUNNING=" /tmp/health_output.log | cut -d'=' -f2 | head -1 | xargs -I {} echo "running_containers={}" >> $GITHUB_OUTPUT
            grep "HEALTH_OUTPUT_SUCCESS_RATE=" /tmp/health_output.log | cut -d'=' -f2 | head -1 | xargs -I {} echo "success_rate={}" >> $GITHUB_OUTPUT
          else
            # Fallback outputs if parsing fails
            echo "healthy_stacks=" >> $GITHUB_OUTPUT
            echo "degraded_stacks=" >> $GITHUB_OUTPUT
            echo "failed_stacks=" >> $GITHUB_OUTPUT
            echo "total_containers=0" >> $GITHUB_OUTPUT
            echo "running_containers=0" >> $GITHUB_OUTPUT
            echo "success_rate=0" >> $GITHUB_OUTPUT
          fi
          
          rm -f /tmp/health_output.log
          echo "::endgroup::"

      - name: Cleanup unused images
        id: cleanup
        if: steps.backup.outputs.deployment_needed == 'true' && steps.deploy.outcome == 'success' && steps.health.outcome == 'success'
        continue-on-error: true
        run: |
          echo "::group::Cleaning up unused Docker images"
          ssh -o "StrictHostKeyChecking no" ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} "
            echo \"üßπ Cleaning up unused Docker images...\"
            docker image prune -af
            echo \"‚úÖ Cleanup completed\"
          "
          echo "::endgroup::"

      - name: Rollback to Previous Version
        id: rollback
        if: steps.backup.outputs.deployment_needed == 'true' && (steps.deploy.outcome == 'failure' || steps.health.outcome == 'failure')
        continue-on-error: true
        run: |
          echo "::group::Rolling back to previous deployment"
          echo "üîÑ **INITIATING ROLLBACK**"
          echo "Previous SHA: ${{ steps.backup.outputs.previous_sha }}"
          echo "Failed SHA: ${{ inputs.target-ref }}"

          # Parse stacks from JSON input
          STACKS="${{ join(fromJson(inputs.stacks), ' ') }}"

          ssh -o "StrictHostKeyChecking no" ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} "
            set -e
            export OP_SERVICE_ACCOUNT_TOKEN=${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}

            echo \"üîÑ Rolling back to ${{ steps.backup.outputs.previous_sha }}...\"
            git -C /opt/compose/ checkout ${{ steps.backup.outputs.previous_sha }}

            for STACK in \$STACKS; do
              echo \"üîÑ Rolling back \$STACK...\"
              cd /opt/compose/\$STACK

              if ! op run --env-file=/opt/compose/compose.env -- docker compose up -d --remove-orphans; then
                echo \"‚ùå Failed to rollback \$STACK\"
              else
                echo \"‚úÖ \$STACK rolled back successfully\"
              fi
            done

            echo \"‚úÖ Rollback completed\"
          "
          echo "::endgroup::"

      - name: Report Deployment Status
        if: always()
        run: |
          echo "::group::Deployment Summary"

          # Parse stacks from JSON input and create display list
          STACK_LIST="${{ join(fromJson(inputs.stacks), ', ') }}"
          if [ "${{ inputs.has-dockge }}" = "true" ]; then
            STACK_LIST="dockge, $STACK_LIST"
          fi

          if [ "${{ steps.backup.outputs.deployment_needed }}" != "true" ]; then
            echo "‚ÑπÔ∏è **NO DEPLOYMENT NEEDED**"
            echo "‚úÖ Repository already at target commit"
            echo "üìã Target stacks: $STACK_LIST"
            echo "üîÑ SHA: ${{ inputs.target-ref }}"
          elif [ "${{ inputs.force-deploy }}" = "true" ] && [ "${{ steps.deploy.outcome }}" == "success" ] && [ "${{ steps.health.outcome }}" == "success" ]; then
            echo "üîÑ **FORCE DEPLOYMENT SUCCESSFUL**"
            echo "‚úÖ All stacks force-deployed and healthy"
            echo "üìã Deployed stacks: $STACK_LIST"
            echo "üîÑ SHA: ${{ inputs.target-ref }}"
            if [ "${{ steps.cleanup.outcome }}" == "success" ]; then
              echo "üßπ Cleanup completed successfully"
            fi
          elif [ "${{ steps.deploy.outcome }}" == "success" ] && [ "${{ steps.health.outcome }}" == "success" ]; then
            echo "üéâ **DEPLOYMENT SUCCESSFUL**"
            echo "‚úÖ All stacks deployed and healthy"
            echo "üìã Deployed stacks: $STACK_LIST"
            echo "üîÑ SHA: ${{ inputs.target-ref }}"
            if [ "${{ steps.cleanup.outcome }}" == "success" ]; then
              echo "üßπ Cleanup completed successfully"
            fi
          else
            echo "üí• **DEPLOYMENT FAILED**"
            echo "‚ùå Deploy status: ${{ steps.deploy.outcome }}"
            echo "‚ùå Health check status: ${{ steps.health.outcome }}"
            if [ "${{ steps.rollback.outcome }}" == "success" ]; then
              echo "üîÑ Rollback completed successfully"
            else
              echo "‚ùå Rollback status: ${{ steps.rollback.outcome }}"
            fi
            exit 1
          fi
          echo "::endgroup::"

  notify:
    name: Discord Notification
    runs-on: ubuntu-latest
    needs: [deploy]
    if: always()
    steps:
      - name: Configure 1Password Service Account
        uses: 1password/load-secrets-action/configure@581a835fb51b8e7ec56b71cf2ffddd7e68bb25e0  # v2.0.0
        with:
          service-account-token: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}

      - name: Load Discord webhook
        id: op-load-discord
        uses: 1password/load-secrets-action@581a835fb51b8e7ec56b71cf2ffddd7e68bb25e0  # v2.0.0
        with:
          export-env: false
          unset-previous: true
        env:
          DISCORD_WEBHOOK: ${{ inputs.webhook-url }}

      - name: Send Discord notification
        uses: sarisia/actions-status-discord@5ddd3b114a98457dd80a39b2f00b6a998cd69008  # v1.15.3
        with:
          webhook: ${{ steps.op-load-discord.outputs.DISCORD_WEBHOOK }}
          status: ${{ needs.deploy.outputs.deployment_needed != 'true' && 'success' || needs.deploy.outputs.deploy_status == 'success' && needs.deploy.outputs.health_status == 'success' && 'success' || 'failure' }}
          title: "üöÄ ${{ inputs.repo-name }} Deployment"
          description: |
            ${{ needs.deploy.outputs.deployment_needed != 'true' && '‚ÑπÔ∏è **NO DEPLOYMENT NEEDED** - Repository already at target commit' || inputs.force-deploy == true && needs.deploy.outputs.deploy_status == 'success' && needs.deploy.outputs.health_status == 'success' && 'üîÑ **FORCE DEPLOYMENT SUCCESSFUL**' || needs.deploy.outputs.deploy_status == 'success' && needs.deploy.outputs.health_status == 'success' && '‚úÖ **DEPLOYMENT SUCCESSFUL**' || needs.deploy.outputs.rollback_status == 'success' && 'üîÑ **DEPLOYMENT FAILED - ROLLED BACK**' || '‚ùå **DEPLOYMENT FAILED**' }}

            ${{ needs.deploy.outputs.deployment_needed == 'true' && format('**Services:** {0}/{1} running ({2}%)', needs.deploy.outputs.running_containers || '?', needs.deploy.outputs.total_containers || '?', needs.deploy.outputs.success_rate || '?') || '**Target Stacks:** Ready for deployment when needed' }}
            ${{ needs.deploy.outputs.healthy_stacks != '' && format('‚úÖ Healthy: {0}', needs.deploy.outputs.healthy_stacks) || '' }}${{ needs.deploy.outputs.degraded_stacks != '' && format('‚ö†Ô∏è Degraded: {0}', needs.deploy.outputs.degraded_stacks) || '' }}${{ needs.deploy.outputs.failed_stacks != '' && format('‚ùå Failed: {0}', needs.deploy.outputs.failed_stacks) || '' }}

            ${{ needs.deploy.outputs.deployment_needed == 'true' && format('**Pipeline:** Deploy {0} ‚Üí Health {1} ‚Üí Cleanup {2}{3}', needs.deploy.outputs.deploy_status == 'success' && '‚úÖ' || '‚ùå', needs.deploy.outputs.health_status == 'success' && '‚úÖ' || needs.deploy.outputs.health_status == 'skipped' && '‚è≠Ô∏è' || '‚ùå', needs.deploy.outputs.cleanup_status == 'success' && '‚úÖ' || needs.deploy.outputs.cleanup_status == 'skipped' && '‚è≠Ô∏è' || '‚ùå', needs.deploy.outputs.rollback_status != 'skipped' && format(' ‚Üí Rollback {0}', needs.deploy.outputs.rollback_status == 'success' && '‚úÖ' || '‚ùå') || '') || '**Status:** No changes detected' }}

            ${{ github.event_name == 'workflow_dispatch' && 'üîß **Manual Trigger**' || format('üìù **Commit:** `{0}`', inputs.target-ref) }}
          color: ${{ needs.deploy.outputs.deployment_needed != 'true' && 0x808080 || needs.deploy.outputs.deploy_status == 'success' && needs.deploy.outputs.health_status == 'success' && 0x00ff00 || needs.deploy.outputs.degraded_stacks != '' && 0xff9900 || 0xff0000 }}
          username: "GitHub Actions"
          avatar_url: "https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png"
