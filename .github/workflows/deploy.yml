name: Deploy Docker Compose

# Refactoring Status:
# ‚úÖ Extracted deployment scripts to scripts/deployment/ (Phases 1-5 complete)
#    - lib/ssh-helpers.sh: SSH retry with consistent logging and operation context
#    - lib/common.sh: Logging, validation, and utility functions
#    - health-check.sh: Single-pass health status reporting (post --wait deployment)
#    - deploy-stacks.sh: Parallel deployment with comprehensive error handling
#    - detect-stack-changes.sh: Multi-method detection for removed/existing/new stacks
#    - cleanup-stack.sh: Individual stack cleanup helper
#    - rollback-stacks.sh: Automated rollback with stack discovery
#
# Future Enhancements:
# - Consider composite actions for Tailscale setup and SSH configuration
# - Evaluate splitting deploy/rollback into separate reusable workflows

on:
  workflow_call:
    inputs:
      args:
        description: "docker compose up -d arguments"
        required: false
        type: string
      stacks:
        description: "JSON array of stack names to deploy (optional - auto-discovered if not provided)"
        required: false
        type: string
        default: ''
      webhook-url:
        description: "1Password reference to Discord webhook URL"
        required: true
        type: string
      repo-name:
        description: "Repository display name for notifications"
        required: true
        type: string
      target-ref:
        description: "Git reference to checkout on remote server"
        required: true
        type: string
      has-dockge:
        description: "Whether this deployment includes Dockge"
        required: false
        type: boolean
        default: false
      force-deploy:
        description: "Force deployment even if repository is already at target commit"
        required: false
        type: boolean
        default: false
      health-check-command-timeout:
        description: "Individual health check command timeout in seconds (default: 5, queries Docker daemon directly)"
        required: false
        type: number
        default: 5
      critical-services:
        description: "JSON array of critical service names (only used when auto-detect-critical is false)"
        required: false
        type: string
        default: '[]'
      auto-detect-critical:
        description: "Auto-detect critical stacks from compose file labels (default: true, set false to use critical-services input)"
        required: false
        type: boolean
        default: true
      failed-container-log-lines:
        description: "Number of log lines to capture from failed/unhealthy containers for debugging (default: 50, set to 0 to disable)"
        required: false
        type: number
        default: 50
      git-fetch-timeout:
        description: "Git fetch operation timeout in seconds (default: 300)"
        required: false
        type: number
        default: 300
      git-checkout-timeout:
        description: "Git checkout operation timeout in seconds (default: 60)"
        required: false
        type: number
        default: 60
      image-pull-timeout:
        description: "Docker image pull timeout in seconds (default: 600)"
        required: false
        type: number
        default: 600
      service-startup-timeout:
        description: "Service startup timeout in seconds (default: 300)"
        required: false
        type: number
        default: 300
      validation-env-timeout:
        description: "Environment validation timeout in seconds (default: 30)"
        required: false
        type: number
        default: 30
      validation-syntax-timeout:
        description: "Syntax validation timeout in seconds (default: 60)"
        required: false
        type: number
        default: 60
      discord-user-id:
        description: "Discord user ID to mention in failure notifications (e.g., '<@123456789>')"
        required: false
        type: string
        default: ''

jobs:
  deploy:
    runs-on: ubuntu-24.04
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    timeout-minutes: 40  # Overall job timeout
    outputs:
      previous_sha: ${{ steps.backup.outputs.previous_sha }}
      deployment_needed: ${{ steps.backup.outputs.deployment_needed }}
      deleted_files: ${{ steps.changed-files.outputs.deleted_files }}
      deploy_status: ${{ (steps.deploy-existing.outcome == 'success' || steps.deploy-existing.outcome == 'skipped') && (steps.deploy-new.outcome == 'success' || steps.deploy-new.outcome == 'skipped') && 'success' || 'failure' }}
      health_status: ${{ steps.health.outcome }}
      cleanup_status: ${{ steps.cleanup.outcome }}
      rollback_status: ${{ steps.rollback.outcome }}
      rollback_health_status: ${{ steps.rollback-health.outcome }}
      discovered_rollback_stacks: ${{ steps.rollback.outputs.discovered_rollback_stacks }}
      healthy_stacks: ${{ steps.health.outputs.healthy_stacks }}
      degraded_stacks: ${{ steps.health.outputs.degraded_stacks }}
      failed_stacks: ${{ steps.health.outputs.failed_stacks }}
      total_containers: ${{ steps.health.outputs.total_containers }}
      running_containers: ${{ steps.health.outputs.running_containers }}
      success_rate: ${{ steps.health.outputs.success_rate }}
      rollback_healthy_stacks: ${{ steps.rollback-health.outputs.rollback_healthy_stacks }}
      rollback_degraded_stacks: ${{ steps.rollback-health.outputs.rollback_degraded_stacks }}
      rollback_failed_stacks: ${{ steps.rollback-health.outputs.rollback_failed_stacks }}
      rollback_total_containers: ${{ steps.rollback-health.outputs.rollback_total_containers }}
      rollback_running_containers: ${{ steps.rollback-health.outputs.rollback_running_containers }}
      rollback_success_rate: ${{ steps.rollback-health.outputs.rollback_success_rate }}
      removed_stacks: ${{ steps.detect-changes.outputs.removed_stacks }}
      existing_stacks: ${{ steps.detect-changes.outputs.existing_stacks }}
      new_stacks: ${{ steps.detect-changes.outputs.new_stacks }}
      has_removed_stacks: ${{ steps.detect-changes.outputs.has_removed_stacks }}
      has_existing_stacks: ${{ steps.detect-changes.outputs.has_existing_stacks }}
      has_new_stacks: ${{ steps.detect-changes.outputs.has_new_stacks }}
    steps:
      - name: Validate and sanitize inputs
        run: |
          # Validate stacks parameter if provided (skip if empty - will be auto-discovered)
          if [ -n "${{ inputs.stacks }}" ]; then
            echo '${{ inputs.stacks }}' | jq -r '.[]' >/dev/null || {
              echo "::error::Invalid stacks JSON format: ${{ inputs.stacks }}"
              exit 1
            }

            # Validate stack names contain only safe characters
            echo '${{ inputs.stacks }}' | jq -r '.[]' | while read -r stack; do
              if [[ ! "$stack" =~ ^[a-zA-Z0-9_-]+$ ]]; then
                echo "::error::Invalid stack name: $stack. Only alphanumeric, underscore, and hyphen allowed."
                exit 1
              fi
              # Check stack name length
              if [ ${#stack} -gt 50 ]; then
                echo "::error::Stack name too long: $stack (max 50 characters)"
                exit 1
              fi
            done
            echo "‚úÖ Stacks input validated"
          else
            echo "‚ÑπÔ∏è Stacks not provided - will be auto-discovered after checkout"
          fi

          # Validate target-ref format using git check-ref-format for accurate validation
          TARGET_REF="${{ inputs.target-ref }}"

          # First check if it's a commit SHA (7-40 hex chars)
          if [[ "$TARGET_REF" =~ ^[a-fA-F0-9]{7,40}$ ]]; then
            echo "‚úÖ Target-ref is a valid commit SHA: $TARGET_REF"
          # Otherwise validate as a git reference (branch/tag)
          elif git check-ref-format --allow-onelevel "$TARGET_REF" 2>/dev/null; then
            echo "‚úÖ Target-ref is a valid git reference: $TARGET_REF"
          else
            echo "::error::Invalid target-ref format: $TARGET_REF"
            echo "::error::Expected: commit SHA (7-40 hex chars) or valid git reference"
            echo "::error::Git references must not contain spaces, ~, ^, :, ?, *, [, \\, or .."
            exit 1
          fi

          # Validate compose args using whitelist approach (more secure than blacklist)
          COMPOSE_ARGS="${{ inputs.args }}"
          if [[ -n "$COMPOSE_ARGS" ]]; then
            echo "üîç Validating compose args: $COMPOSE_ARGS"

            # Whitelist of allowed docker compose up arguments
            ALLOWED_ARGS=(
              "--force-recreate" "--no-recreate"
              "--build" "--no-build"
              "--pull" "--no-pull"
              "--quiet-pull"
              "--no-deps"
              "--remove-orphans"
              "--wait" "--no-wait"
              "--wait-timeout"
              "--no-start"
              "--attach" "--no-attach"
              "--attach-dependencies"
            )

            # Split args and validate each one
            VALIDATION_FAILED=false
            for arg in $COMPOSE_ARGS; do
              # Check if it's a numeric value (for --wait-timeout)
              if [[ "$arg" =~ ^[0-9]+$ ]]; then
                continue
              fi

              # Check if it's in the whitelist
              FOUND=false
              for allowed in "${ALLOWED_ARGS[@]}"; do
                if [[ "$arg" == "$allowed" ]]; then
                  FOUND=true
                  break
                fi
              done

              if [[ "$FOUND" == "false" ]]; then
                echo "::error::Unrecognized or prohibited compose argument: $arg"
                VALIDATION_FAILED=true
              fi
            done

            if [[ "$VALIDATION_FAILED" == "true" ]]; then
              echo "::error::Only whitelisted docker compose up arguments are allowed"
              echo "::error::Allowed: ${ALLOWED_ARGS[*]} (and numeric values for timeouts)"
              exit 1
            fi

            echo "‚úÖ Compose args validation passed: $COMPOSE_ARGS"
          fi

          # Validate webhook URL format
          WEBHOOK_URL="${{ inputs.webhook-url }}"
          if [[ ! "$WEBHOOK_URL" =~ ^op://[a-zA-Z0-9_-]+/[a-zA-Z0-9_-]+/[a-zA-Z0-9_-]+$ ]]; then
            echo "::error::Invalid webhook URL format: $WEBHOOK_URL"
            echo "::error::Expected format: op://vault/item/field"
            exit 1
          fi

          # Validate repo name
          REPO_NAME="${{ inputs.repo-name }}"
          if [[ ! "$REPO_NAME" =~ ^[a-zA-Z0-9_-]+$ ]] || [ ${#REPO_NAME} -gt 100 ]; then
            echo "::error::Invalid repo name: $REPO_NAME"
            echo "::error::Must be alphanumeric with hyphens/underscores, max 100 chars"
            exit 1
          fi

          echo "‚úÖ All input validation passed"

      - name: Display version information
        run: |
          echo "üìã Workflow Version Information"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "Repository: ${{ inputs.repo-name }}"
          echo "Target ref: ${{ inputs.target-ref }}"
          echo "Stacks: ${{ inputs.stacks || '(auto-discover)' }}"
          echo "Runner: ${{ runner.os }} ${{ runner.arch }}"
          echo ""
          echo "‚ÑπÔ∏è  Reusable workflow SHA shown in 'Uses:' line above"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

      - name: Verify required tools
        run: |
          echo "üîç Verifying required tools are available..."

          # Verify jq is available (pre-installed on ubuntu-24.04)
          echo "‚úÖ jq version: $(jq --version)"

          # Verify timeout is available (part of coreutils)
          echo "‚úÖ timeout is available (part of coreutils)"

          # Verify Bash 4.0+ for readarray and associative arrays
          if [ "${BASH_VERSION%%.*}" -lt 4 ]; then
            echo "::error::Bash 4.0+ is required (current: ${BASH_VERSION:-unknown})"
            exit 1
          fi
          echo "‚úÖ Bash version: $BASH_VERSION (supports readarray and associative arrays)"

          echo "‚úÖ All required tools verified"

      - name: Cache deployment tools
        uses: actions/cache@8b402f58fbc84540c8b491a91e594a4576fec3d7  # v5.0.2
        with:
          path: |
            ~/.cache/pip
            ~/.cache/docker
            ~/.ssh
          key: deploy-tools-${{ runner.os }}-v1
          restore-keys: |
            deploy-tools-${{ runner.os }}-

      - name: Configure 1Password Service Account
        uses: 1password/load-secrets-action/configure@8d0d610af187e78a2772c2d18d627f4c52d3fbfb  # v3.1.0
        with:
          service-account-token: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}

      - name: Load Tailscale credentials
        id: load-tailscale-credentials
        uses: 1password/load-secrets-action@8d0d610af187e78a2772c2d18d627f4c52d3fbfb  # v3.1.0
        with:
          unset-previous: true
        env:
          TAILSCALE_OAUTH_CLIENT_ID: "op://Docker/tailscale-oauth/client_id"
          TAILSCALE_OAUTH_SECRET: "op://Docker/tailscale-oauth/secret"

      - name: Connect to Tailnet
        uses: tailscale/github-action@53acf823325fe9ca47f4cdaa951f90b4b0de5bb9  # v4.1.1
        with:
          oauth-client-id: ${{ steps.load-tailscale-credentials.outputs.TAILSCALE_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ steps.load-tailscale-credentials.outputs.TAILSCALE_OAUTH_SECRET }}
          tags: tag:ci
          ping: ${{ secrets.SSH_HOST }}

      - name: Unload Tailscale credentials
        uses: 1password/load-secrets-action@8d0d610af187e78a2772c2d18d627f4c52d3fbfb  # v3.1.0
        with:
          unset-previous: true

      - name: Configure SSH known hosts
        run: |
          # Add deployment server to known_hosts for security
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "üîê Adding deployment server to known_hosts..."
          ssh-keyscan -H ${{ secrets.SSH_HOST }} >> ~/.ssh/known_hosts 2>/dev/null
          chmod 600 ~/.ssh/known_hosts
          echo "‚úÖ Known hosts configured"

      - name: Optimize SSH connections
        run: |
          # Configure SSH connection multiplexing for better performance
          cat >> ~/.ssh/config << EOF
          Host deployment-server
            HostName ${{ secrets.SSH_HOST }}
            User ${{ secrets.SSH_USER }}
            ControlMaster auto
            ControlPath ~/.ssh/sockets/%r@%h:%p
            ControlPersist 300
            ServerAliveInterval 30
            ServerAliveCountMax 3
            Compression yes
            TCPKeepAlive yes
          EOF

          # Create control socket directory and establish master connection
          mkdir -p ~/.ssh/sockets
          echo "üîó Establishing SSH master connection for multiplexing..."
          ssh -o "ControlMaster yes" \
              -o "ControlPath ~/.ssh/sockets/%r@%h:%p" \
              -o "ControlPersist 600" \
              -N -f deployment-server || {
            echo "::warning::Failed to establish SSH master connection, will use direct connections"
          }

          # Verify connection
          if ssh -o "ControlPath ~/.ssh/sockets/%r@%h:%p" -O check deployment-server 2>/dev/null; then
            echo "‚úÖ SSH master connection established"
          else
            echo "::warning::SSH multiplexing not available"
          fi

      - name: Checkout repository for change detection
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd  # v6.0.2
        with:
          fetch-depth: 0  # Fetch full history for accurate change detection

      - name: Discover stacks
        id: discover-stacks
        run: |
          # Use provided stacks input if available, otherwise auto-discover
          if [ -n "${{ inputs.stacks }}" ]; then
            echo "üìã Using provided stacks: ${{ inputs.stacks }}"
            echo "stacks=${{ inputs.stacks }}" >> "$GITHUB_OUTPUT"
          else
            echo "üîç Auto-discovering stacks from repository..."
            stacks=()
            for dir in */; do
              dir_name=$(basename "$dir")
              if [[ -f "$dir/compose.yml" || -f "$dir/compose.yaml" ]]; then
                stacks+=("\"$dir_name\"")
              fi
            done

            if [ ${#stacks[@]} -eq 0 ]; then
              echo "::error::No Docker Compose stacks found in repository"
              exit 1
            fi

            # Join array elements with commas and wrap in brackets
            stack_json="[$(IFS=,; echo "${stacks[*]}")]"
            echo "stacks=$stack_json" >> "$GITHUB_OUTPUT"
            echo "‚úÖ Discovered stacks: $stack_json"
          fi

      - name: Checkout compose-workflow for deployment scripts
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd  # v6.0.2
        with:
          repository: owine/compose-workflow
          ref: main
          path: .compose-workflow

      - name: Determine previous deployment SHA
        id: determine-previous
        run: |
          # Use retry mechanism for SSH connection
          source ./.compose-workflow/scripts/deployment/lib/ssh-helpers.sh

          # Get current deployment SHA with error handling
          echo "üîç Checking current deployment SHA for change detection..."
          if CURRENT_SHA=$(ssh_retry 3 5 "ssh ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} 'cd /opt/compose && git rev-parse HEAD 2>/dev/null'"); then
            # Validate SHA format
            if [[ "$CURRENT_SHA" =~ ^[a-fA-F0-9]{40}$ ]]; then
              echo "‚úÖ Current deployed SHA: $CURRENT_SHA"
              echo "previous_sha=$CURRENT_SHA" >> "$GITHUB_OUTPUT"
            else
              echo "‚ö†Ô∏è Invalid SHA format from server: $CURRENT_SHA"
              echo "‚ö†Ô∏è Using HEAD^ as fallback for change detection"
              echo "previous_sha=HEAD^" >> "$GITHUB_OUTPUT"
            fi
          else
            echo "‚ö†Ô∏è Could not retrieve current deployment SHA - using HEAD^ for change detection"
            echo "previous_sha=HEAD^" >> "$GITHUB_OUTPUT"
          fi

      - name: Get changed files for removal detection
        id: changed-files
        if: steps.determine-previous.outputs.previous_sha != inputs.target-ref
        continue-on-error: true
        uses: tj-actions/changed-files@e0021407031f5be11a464abee9a0776171c79891 # v47.0.1
        with:
          json: true
          sha: ${{ inputs.target-ref }}
          base_sha: ${{ steps.determine-previous.outputs.previous_sha }}

      - name: Store current deployment for rollback
        id: backup
        run: |
          echo "::group::Preparing deployment backup"
          # Use retry mechanism for SSH connection
          source ./.compose-workflow/scripts/deployment/lib/ssh-helpers.sh

          # Get current deployment SHA with error handling
          echo "üîç Checking current deployment SHA..."
          if CURRENT_SHA=$(ssh_retry 3 5 "ssh ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} 'cd /opt/compose && git rev-parse HEAD 2>/dev/null'"); then
            # Validate SHA format
            if [[ "$CURRENT_SHA" =~ ^[a-fA-F0-9]{40}$ ]]; then
              echo "‚úÖ Current deployed SHA: $CURRENT_SHA"
            else
              echo "‚ö†Ô∏è Invalid SHA format from server: $CURRENT_SHA"
              CURRENT_SHA="unknown"
            fi
          else
            echo "‚ö†Ô∏è Could not retrieve current deployment SHA - assuming first deployment"
            CURRENT_SHA="unknown"
          fi

          TARGET_REF="${{ inputs.target-ref }}"
          echo "üéØ Target deployment ref: $TARGET_REF"

          # Resolve target ref to SHA if it's not already a SHA
          if [[ "$TARGET_REF" =~ ^[a-fA-F0-9]{40}$ ]]; then
            TARGET_SHA="$TARGET_REF"
            echo "‚úÖ Target ref is already a full SHA"
          elif [[ "$TARGET_REF" =~ ^[a-fA-F0-9]{7,39}$ ]]; then
            TARGET_SHA="$TARGET_REF"
            echo "‚úÖ Target ref is a short SHA, will resolve on server"
          else
            TARGET_SHA="$TARGET_REF"
            echo "‚úÖ Target ref is a branch/tag name, will resolve on server"
          fi

          # Set outputs with proper validation
          echo "previous_sha=${CURRENT_SHA}" >> "$GITHUB_OUTPUT"

          if [ "$CURRENT_SHA" = "$TARGET_SHA" ] && [ "${{ inputs.force-deploy }}" != "true" ]; then
            echo "‚ö†Ô∏è Repository is already at target commit - no deployment needed"
            echo "deployment_needed=false" >> "$GITHUB_OUTPUT"
          elif [ "$CURRENT_SHA" = "$TARGET_SHA" ] && [ "${{ inputs.force-deploy }}" = "true" ]; then
            echo "üîÑ Force deployment requested - proceeding despite same commit"
            echo "deployment_needed=true" >> "$GITHUB_OUTPUT"
          else
            echo "‚úÖ Deployment needed - proceeding with update"
            echo "deployment_needed=true" >> "$GITHUB_OUTPUT"
          fi
          echo "::endgroup::"

      # ================================================================
      # STACK REMOVAL DETECTION AND CLEANUP
      # ================================================================
      # Automatically detect and clean up Docker stacks that have been
      # removed from the repository using three independent detection methods.
      #
      # Detection Methods:
      # 1. Git Diff: Compares current deployed SHA vs target SHA
      # 2. Tree Comparison: Compares target commit tree vs server filesystem
      #    (catches removals from previous undeployed commits)
      # 3. Discovery Analysis: Analyzes tj-actions/changed-files output
      #    (validates removals from GitHub perspective)
      #
      # Process:
      # 1. Run all three detection methods independently on deployment server
      # 2. Fail deployment if ANY detection method encounters errors (fail-safe)
      # 3. Aggregate results using union approach (remove anything found by any method)
      # 4. Deduplicate and validate stack names
      # 5. Run 'docker compose down' for each removed stack
      # 6. Fail deployment if any cleanup fails
      # 7. Send Discord notification listing removed stacks
      #
      # Design: docs/plans/2025-12-06-enhanced-stack-removal-detection-design.md

      - name: Detect stack changes (removed/existing/new)
        id: detect-changes
        if: steps.backup.outputs.deployment_needed == 'true'
        continue-on-error: false
        run: |
          ./.compose-workflow/scripts/deployment/detect-stack-changes.sh \
            --current-sha "${{ steps.backup.outputs.previous_sha }}" \
            --target-ref "${{ inputs.target-ref }}" \
            --input-stacks '${{ steps.discover-stacks.outputs.stacks }}' \
            --removed-files '${{ steps.changed-files.outputs.deleted_files }}' \
            --ssh-user "${{ secrets.SSH_USER }}" \
            --ssh-host "${{ secrets.SSH_HOST }}"

      - name: Notify removed stacks cleanup
        if: steps.detect-changes.outputs.has_removed_stacks == 'true'
        run: |
          echo "üì¢ Sending cleanup notification to Discord..."

          # Get webhook URL from 1Password
          WEBHOOK_URL=$(op read "${{ inputs.webhook-url }}")

          # Build removed stacks list and create JSON payload using jq for proper escaping
          REMOVED_STACKS='${{ steps.detect-changes.outputs.removed_stacks }}'
          STACK_LIST=$(echo "$REMOVED_STACKS" | jq -r '.[] | "- " + .')
          TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)

          # Build JSON payload with jq to ensure proper escaping
          PAYLOAD=$(jq -n \
            --arg title "üóëÔ∏è Stack Cleanup - ${{ inputs.repo-name }}" \
            --arg description "Removed stacks have been cleaned up before deployment" \
            --arg stacks "$STACK_LIST" \
            --arg target "${{ inputs.target-ref }}" \
            --arg previous "${{ steps.backup.outputs.previous_sha }}" \
            --arg timestamp "$TIMESTAMP" \
            '{
              embeds: [{
                title: $title,
                description: $description,
                color: 16753920,
                fields: [
                  {name: "Removed Stacks", value: $stacks},
                  {name: "Target Commit", value: ("`" + $target + "`")},
                  {name: "Previous Commit", value: ("`" + $previous + "`")}
                ],
                timestamp: $timestamp
              }]
            }')

          # Send Discord notification with timeout protection
          if curl -X POST "$WEBHOOK_URL" \
            --connect-timeout 10 \
            --max-time 30 \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD"; then
            echo "‚úÖ Cleanup notification sent"
          else
            echo "::warning::Discord cleanup notification failed (timeout or network error)"
          fi

      - name: Detect critical stacks
        id: detect-critical
        if: steps.backup.outputs.deployment_needed == 'true' && inputs.auto-detect-critical == true
        run: |
          ./.compose-workflow/scripts/deployment/detect-critical-stacks.sh \
            --stacks "${{ join(fromJSON(steps.discover-stacks.outputs.stacks), ' ') }}" \
            --ssh-user "${{ secrets.SSH_USER }}" \
            --ssh-host "${{ secrets.SSH_HOST }}"

      - name: Deploy Dockge
        id: deploy-dockge
        if: steps.backup.outputs.deployment_needed == 'true' && inputs.has-dockge == true
        continue-on-error: true
        run: |
          ./.compose-workflow/scripts/deployment/deploy-dockge.sh \
            --ssh-user "${{ secrets.SSH_USER }}" \
            --ssh-host "${{ secrets.SSH_HOST }}" \
            --op-token "${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}" \
            --image-timeout "${{ inputs.image-pull-timeout }}" \
            --startup-timeout "${{ inputs.service-startup-timeout }}" \
            --compose-args "${{ inputs.args || '' }}"

      - name: Deploy Existing Stacks
        id: deploy-existing
        if: steps.backup.outputs.deployment_needed == 'true' && steps.detect-changes.outputs.has_existing_stacks == 'true' && (inputs.has-dockge == false || steps.deploy-dockge.outcome == 'success')
        continue-on-error: true
        run: |
          echo "üîÑ Deploying existing stacks (updates)..."
          ./.compose-workflow/scripts/deployment/deploy-stacks.sh \
            --stacks "${{ join(fromJSON(steps.detect-changes.outputs.existing_stacks), ' ') }}" \
            --target-ref "${{ inputs.target-ref }}" \
            --compose-args "${{ inputs.args || '' }}" \
            --ssh-user "${{ secrets.SSH_USER }}" \
            --ssh-host "${{ secrets.SSH_HOST }}" \
            --op-token "${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}" \
            --git-fetch-timeout "${{ inputs.git-fetch-timeout }}" \
            --git-checkout-timeout "${{ inputs.git-checkout-timeout }}" \
            --image-pull-timeout "${{ inputs.image-pull-timeout }}" \
            --service-startup-timeout "${{ inputs.service-startup-timeout }}" \
            --validation-env-timeout "${{ inputs.validation-env-timeout }}" \
            --validation-syntax-timeout "${{ inputs.validation-syntax-timeout }}"

      - name: Deploy New Stacks
        id: deploy-new
        if: steps.backup.outputs.deployment_needed == 'true' && steps.detect-changes.outputs.has_new_stacks == 'true' && (inputs.has-dockge == false || steps.deploy-dockge.outcome == 'success') && (steps.detect-changes.outputs.has_existing_stacks == 'false' || steps.deploy-existing.outcome == 'success')
        continue-on-error: true
        run: |
          echo "‚ú® Deploying new stacks (fresh deployments)..."
          ./.compose-workflow/scripts/deployment/deploy-stacks.sh \
            --stacks "${{ join(fromJSON(steps.detect-changes.outputs.new_stacks), ' ') }}" \
            --target-ref "${{ inputs.target-ref }}" \
            --compose-args "${{ inputs.args || '' }}" \
            --ssh-user "${{ secrets.SSH_USER }}" \
            --ssh-host "${{ secrets.SSH_HOST }}" \
            --op-token "${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}" \
            --git-fetch-timeout "${{ inputs.git-fetch-timeout }}" \
            --git-checkout-timeout "${{ inputs.git-checkout-timeout }}" \
            --image-pull-timeout "${{ inputs.image-pull-timeout }}" \
            --service-startup-timeout "${{ inputs.service-startup-timeout }}" \
            --validation-env-timeout "${{ inputs.validation-env-timeout }}" \
            --validation-syntax-timeout "${{ inputs.validation-syntax-timeout }}"

      - name: Health Check All Services
        id: health
        if: steps.backup.outputs.deployment_needed == 'true' && (steps.deploy-existing.outcome == 'success' || steps.deploy-existing.outcome == 'skipped') && (steps.deploy-new.outcome == 'success' || steps.deploy-new.outcome == 'skipped')
        continue-on-error: true
        run: |
          # Use auto-detected critical stacks if enabled, otherwise use manual input
          if [ "${{ inputs.auto-detect-critical }}" = "true" ]; then
            CRITICAL_SERVICES='${{ steps.detect-critical.outputs.critical_stacks }}'
          else
            CRITICAL_SERVICES='${{ inputs.critical-services }}'
          fi

          ./.compose-workflow/scripts/deployment/health-check.sh \
            --stacks "${{ join(fromJSON(steps.discover-stacks.outputs.stacks), ' ') }}" \
            --has-dockge "${{ inputs.has-dockge }}" \
            --ssh-user "${{ secrets.SSH_USER }}" \
            --ssh-host "${{ secrets.SSH_HOST }}" \
            --command-timeout "${{ inputs.health-check-command-timeout }}" \
            --critical-services "$CRITICAL_SERVICES" \
            --failed-container-log-lines "${{ inputs.failed-container-log-lines }}"

      - name: Cleanup unused images
        id: cleanup
        if: steps.backup.outputs.deployment_needed == 'true' && (steps.deploy-existing.outcome == 'success' || steps.deploy-existing.outcome == 'skipped') && (steps.deploy-new.outcome == 'success' || steps.deploy-new.outcome == 'skipped') && steps.health.outcome == 'success'
        continue-on-error: true
        run: |
          echo "::group::Cleaning up unused Docker images"
          ssh ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} << EOF
            echo "üßπ Cleaning up unused Docker images..."
            docker image prune -f
            echo "‚úÖ Cleanup completed"
          EOF
          echo "::endgroup::"

      # Note: Dockge rollback removed - Dockge is a management UI and doesn't need
      # to be rolled back when stack deployments fail. Stack rollback is sufficient.

      - name: Rollback to Previous Version
        id: rollback
        if: steps.backup.outputs.deployment_needed == 'true' && (steps.deploy-existing.outcome == 'failure' || steps.deploy-new.outcome == 'failure' || steps.health.outcome == 'failure')
        continue-on-error: true
        run: |
          echo "üîÑ **INITIATING ROLLBACK**"
          echo "Previous SHA: ${{ steps.backup.outputs.previous_sha }}"
          echo "Failed SHA: ${{ inputs.target-ref }}"

          # Use auto-detected critical stacks if enabled, otherwise use manual input
          if [ "${{ inputs.auto-detect-critical }}" = "true" ]; then
            CRITICAL_SERVICES='${{ steps.detect-critical.outputs.critical_stacks }}'
          else
            CRITICAL_SERVICES='${{ inputs.critical-services }}'
          fi

          ./.compose-workflow/scripts/deployment/rollback-stacks.sh \
            --previous-sha "${{ steps.backup.outputs.previous_sha }}" \
            --compose-args "${{ inputs.args || '' }}" \
            --critical-services "$CRITICAL_SERVICES" \
            --ssh-user "${{ secrets.SSH_USER }}" \
            --ssh-host "${{ secrets.SSH_HOST }}" \
            --op-token "${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}" \
            --git-fetch-timeout "${{ inputs.git-fetch-timeout }}" \
            --git-checkout-timeout "${{ inputs.git-checkout-timeout }}" \
            --image-pull-timeout "${{ inputs.image-pull-timeout }}" \
            --service-startup-timeout "${{ inputs.service-startup-timeout }}" \
            --validation-env-timeout "${{ inputs.validation-env-timeout }}" \
            --validation-syntax-timeout "${{ inputs.validation-syntax-timeout }}"

      # Health check runs after rollback attempt regardless of rollback success/failure
      # This is intentional: we need to know the final system state even if rollback fails
      # Using 'conclusion != skipped' instead of 'outcome == success' ensures we get
      # visibility into what services are running, which is critical for incident response
      - name: Verify Rollback Health
        id: rollback-health
        if: steps.backup.outputs.deployment_needed == 'true' && (steps.deploy-existing.outcome == 'failure' || steps.deploy-new.outcome == 'failure' || steps.health.outcome == 'failure') && steps.rollback.conclusion != 'skipped'
        continue-on-error: true
        run: |
          echo "üîç Verifying rollback health status"

          # Use discovered rollback stacks instead of input stacks
          # This ensures we check the stacks that were actually rolled back (from previous commit)
          DISCOVERED_STACKS="${{ steps.rollback.outputs.discovered_rollback_stacks }}"
          if [ -n "$DISCOVERED_STACKS" ]; then
            # Convert newline-delimited stacks to space-delimited
            readarray -t STACKS_ARRAY <<< "$DISCOVERED_STACKS"
            STACKS="${STACKS_ARRAY[*]}"
            echo "‚úÖ Using discovered rollback stacks: $STACKS"
          else
            # Fallback to discovered stacks if rollback discovery failed
            STACKS="${{ join(fromJSON(steps.discover-stacks.outputs.stacks), ' ') }}"
            echo "‚ö†Ô∏è Using discovered stacks as fallback: $STACKS"
          fi

          # Use auto-detected critical stacks if enabled, otherwise use manual input
          if [ "${{ inputs.auto-detect-critical }}" = "true" ]; then
            CRITICAL_SERVICES='${{ steps.detect-critical.outputs.critical_stacks }}'
          else
            CRITICAL_SERVICES='${{ inputs.critical-services }}'
          fi

          # Create temporary file to capture health-check.sh outputs
          TEMP_OUTPUT=$(mktemp)

          # Call health-check.sh with rollback context
          if GITHUB_OUTPUT="$TEMP_OUTPUT" ./.compose-workflow/scripts/deployment/health-check.sh \
            --stacks "$STACKS" \
            --has-dockge "${{ inputs.has-dockge }}" \
            --ssh-user "${{ secrets.SSH_USER }}" \
            --ssh-host "${{ secrets.SSH_HOST }}" \
            --command-timeout "${{ inputs.health-check-command-timeout }}" \
            --critical-services "$CRITICAL_SERVICES"; then
            echo "‚úÖ Rollback health check completed"
          else
            echo "‚ö†Ô∏è Rollback health check completed with warnings"
          fi

          # Read outputs from health-check.sh and re-output with rollback_ prefix
          if [ -f "$TEMP_OUTPUT" ]; then
            # Parse each output and add rollback_ prefix
            HEALTHY=$(grep "^healthy_stacks=" "$TEMP_OUTPUT" | cut -d'=' -f2-)
            DEGRADED=$(grep "^degraded_stacks=" "$TEMP_OUTPUT" | cut -d'=' -f2-)
            FAILED=$(grep "^failed_stacks=" "$TEMP_OUTPUT" | cut -d'=' -f2-)
            TOTAL=$(grep "^total_containers=" "$TEMP_OUTPUT" | cut -d'=' -f2-)
            RUNNING=$(grep "^running_containers=" "$TEMP_OUTPUT" | cut -d'=' -f2-)
            RATE=$(grep "^success_rate=" "$TEMP_OUTPUT" | cut -d'=' -f2-)

            # Output with rollback_ prefix for workflow compatibility
            {
              echo "rollback_healthy_stacks=${HEALTHY:-}"
              echo "rollback_degraded_stacks=${DEGRADED:-}"
              echo "rollback_failed_stacks=${FAILED:-}"
              echo "rollback_total_containers=${TOTAL:-0}"
              echo "rollback_running_containers=${RUNNING:-0}"
              echo "rollback_success_rate=${RATE:-0}"
            } >> "$GITHUB_OUTPUT"

            # Cleanup
            rm -f "$TEMP_OUTPUT"
          else
            # Fallback outputs if temp file doesn't exist
            {
              echo "rollback_healthy_stacks="
              echo "rollback_degraded_stacks="
              echo "rollback_failed_stacks="
              echo "rollback_total_containers=0"
              echo "rollback_running_containers=0"
              echo "rollback_success_rate=0"
            } >> "$GITHUB_OUTPUT"
          fi

      - name: Cleanup SSH connections
        if: always()
        run: |
          # Close SSH connection multiplexing
          echo "üßπ Cleaning up SSH connections..."
          ssh deployment-server -O exit 2>/dev/null || true

          # Clean up SSH control sockets
          rm -f ~/.ssh/sockets/* 2>/dev/null || true

          echo "‚úÖ SSH cleanup completed"

      - name: Report Deployment Status
        if: always()
        run: |
          echo "::group::Deployment Summary"

          # Parse stacks from discovered output and create display list
          # Use empty array fallback when discover-stacks step didn't run (early failure)
          STACK_LIST="${{ join(fromJson(steps.discover-stacks.outputs.stacks || '[]'), ', ') }}"
          if [ "${{ inputs.has-dockge }}" = "true" ]; then
            STACK_LIST="dockge, $STACK_LIST"
          fi

          if [ "${{ steps.backup.outputs.deployment_needed }}" == "false" ]; then
            echo "‚ÑπÔ∏è **NO DEPLOYMENT NEEDED**"
            echo "‚úÖ Repository already at target commit"
            echo "üìã Target stacks: $STACK_LIST"
            echo "üîÑ SHA: ${{ inputs.target-ref }}"
          elif [[ "${{ inputs.force-deploy }}" = "true" && ("${{ steps.deploy-existing.outcome }}" == "success" || "${{ steps.deploy-existing.outcome }}" == "skipped") && ("${{ steps.deploy-new.outcome }}" == "success" || "${{ steps.deploy-new.outcome }}" == "skipped") && "${{ steps.health.outcome }}" == "success" ]]; then
            echo "üîÑ **FORCE DEPLOYMENT SUCCESSFUL**"
            echo "‚úÖ All stacks force-deployed and healthy"
            echo "üìã Deployed stacks: $STACK_LIST"
            echo "üîÑ SHA: ${{ inputs.target-ref }}"
            if [ "${{ steps.cleanup.outcome }}" == "success" ]; then
              echo "üßπ Cleanup completed successfully"
            fi
          elif [[ ("${{ steps.deploy-existing.outcome }}" == "success" || "${{ steps.deploy-existing.outcome }}" == "skipped") && ("${{ steps.deploy-new.outcome }}" == "success" || "${{ steps.deploy-new.outcome }}" == "skipped") && "${{ steps.health.outcome }}" == "success" ]]; then
            echo "üéâ **DEPLOYMENT SUCCESSFUL**"
            echo "‚úÖ All stacks deployed and healthy"
            echo "üìã Deployed stacks: $STACK_LIST"
            echo "üîÑ SHA: ${{ inputs.target-ref }}"
            if [ "${{ steps.cleanup.outcome }}" == "success" ]; then
              echo "üßπ Cleanup completed successfully"
            fi
          else
            echo "üí• **DEPLOYMENT FAILED**"
            echo "‚ùå Deploy existing status: ${{ steps.deploy-existing.outcome }}"
            echo "‚ùå Deploy new status: ${{ steps.deploy-new.outcome }}"
            echo "‚ùå Health check status: ${{ steps.health.outcome }}"
            if [ "${{ steps.rollback.outcome }}" == "success" ]; then
              echo "üîÑ Rollback completed successfully"
              if [ "${{ steps.rollback-health.outcome }}" == "success" ]; then
                echo "‚úÖ Rollback verification passed"
              elif [ "${{ steps.rollback-health.outcome }}" == "failure" ]; then
                echo "‚ö†Ô∏è Rollback verification failed - manual intervention may be needed"
              fi
            else
              echo "‚ùå Rollback status: ${{ steps.rollback.outcome }}"
            fi
            exit 1
          fi
          echo "::endgroup::"

  notify:
    name: Discord Notification
    runs-on: ubuntu-24.04
    needs: [deploy]
    if: always()
    steps:
      - name: Configure 1Password Service Account
        uses: 1password/load-secrets-action/configure@8d0d610af187e78a2772c2d18d627f4c52d3fbfb  # v3.1.0
        with:
          service-account-token: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}

      - name: Get commit message
        id: commit-msg
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          COMMIT_MSG=$(gh api repos/${{ github.repository }}/commits/${{ inputs.target-ref }} \
            --jq '.commit.message // "No commit message available"' | head -1)
          SHORT_SHA="${{ inputs.target-ref }}"
          SHORT_SHA="${SHORT_SHA:0:7}"
          echo "message=$COMMIT_MSG" >> "$GITHUB_OUTPUT"
          echo "short-sha=$SHORT_SHA" >> "$GITHUB_OUTPUT"

      - name: Load Discord webhook and user ID
        id: op-load-discord
        uses: 1password/load-secrets-action@8d0d610af187e78a2772c2d18d627f4c52d3fbfb  # v3.1.0
        with:
          unset-previous: true
        env:
          DISCORD_WEBHOOK: ${{ inputs.webhook-url }}
          DISCORD_USER_ID: ${{ inputs.discord-user-id != '' && inputs.discord-user-id || 'SKIP' }}

      - name: Send Discord notification
        uses: sarisia/actions-status-discord@eb045afee445dc055c18d3d90bd0f244fd062708  # v1.16.0
        with:
          webhook: ${{ steps.op-load-discord.outputs.DISCORD_WEBHOOK }}
          content: ${{ needs.deploy.outputs.deployment_needed != 'false' && (needs.deploy.outputs.deploy_status != 'success' || needs.deploy.outputs.health_status != 'success' || needs.deploy.result != 'success') && inputs.discord-user-id != '' && steps.op-load-discord.outputs.DISCORD_USER_ID != 'SKIP' && format('<@{0}>', steps.op-load-discord.outputs.DISCORD_USER_ID) || '' }}
          status: ${{ needs.deploy.result == 'success' && needs.deploy.outputs.deployment_needed == 'false' && 'success' || needs.deploy.outputs.deploy_status == 'success' && needs.deploy.outputs.health_status == 'success' && 'success' || 'failure' }}
          title: "üöÄ ${{ inputs.repo-name }} ‚Ä¢ ${{ needs.deploy.result == 'success' && needs.deploy.outputs.deployment_needed == 'false' && 'No Changes' || needs.deploy.outputs.deploy_status == 'success' && needs.deploy.outputs.health_status == 'success' && 'Deployed' || needs.deploy.outputs.rollback_status == 'success' && 'Rolled Back' || 'Failed' }}"
          description: |
            ${{ needs.deploy.result == 'success' && needs.deploy.outputs.deployment_needed == 'false' && 'üìã **Repository already at target commit**' ||
            inputs.force-deploy == true && needs.deploy.outputs.deploy_status == 'success' && needs.deploy.outputs.health_status == 'success' && 'üîÑ **Force deployment completed successfully**' ||
            needs.deploy.outputs.deploy_status == 'success' && needs.deploy.outputs.health_status == 'success' && '‚úÖ **Deployment completed successfully**' ||
            needs.deploy.outputs.rollback_status == 'success' && 'üîÑ **Deployment failed but rolled back successfully**' || '‚ùå **Deployment failed**' }}

            ${{ needs.deploy.outputs.deployment_needed == 'true' && needs.deploy.outputs.rollback_status != 'success' &&
            format('**üìä Health Status**
            üü¢ Running: {0}/{1} services ({2}%)', needs.deploy.outputs.running_containers || '0',
            needs.deploy.outputs.total_containers || '0', needs.deploy.outputs.success_rate || '0') ||
            needs.deploy.outputs.rollback_status == 'success' && format('**üìä Rollback Health**
            üü¢ Running: {0}/{1} services ({2}%)',
            needs.deploy.outputs.rollback_running_containers || '0', needs.deploy.outputs.rollback_total_containers || '0',
            needs.deploy.outputs.rollback_success_rate || '0') || '' }}

            ${{ needs.deploy.outputs.rollback_status != 'success' && (needs.deploy.outputs.healthy_stacks != '' || needs.deploy.outputs.degraded_stacks != '' || needs.deploy.outputs.failed_stacks != '') &&
            format('**üè∑Ô∏è Stack Status**
            {0}{1}{2}',
            needs.deploy.outputs.healthy_stacks != '' && format('‚úÖ {0}
            ', needs.deploy.outputs.healthy_stacks) || '',
            needs.deploy.outputs.degraded_stacks != '' && format('‚ö†Ô∏è  {0}
            ', needs.deploy.outputs.degraded_stacks) || '',
            needs.deploy.outputs.failed_stacks != '' && format('‚ùå {0}', needs.deploy.outputs.failed_stacks) || '') || '' }}

            ${{ needs.deploy.outputs.rollback_status == 'success' && (needs.deploy.outputs.rollback_healthy_stacks != '' || needs.deploy.outputs.rollback_degraded_stacks != '' || needs.deploy.outputs.rollback_failed_stacks != '') &&
            format('**üè∑Ô∏è Rollback Stack Status**
            {0}{1}{2}',
            needs.deploy.outputs.rollback_healthy_stacks != '' && format('‚úÖ {0}
            ', needs.deploy.outputs.rollback_healthy_stacks) || '',
            needs.deploy.outputs.rollback_degraded_stacks != '' && format('‚ö†Ô∏è  {0}
            ', needs.deploy.outputs.rollback_degraded_stacks) || '',
            needs.deploy.outputs.rollback_failed_stacks != '' && format('‚ùå {0}', needs.deploy.outputs.rollback_failed_stacks) || '') || '' }}

            ${{ needs.deploy.outputs.deployment_needed == 'true' && format('**üîÑ Pipeline Status**
            {0} Deploy ‚Üí {1} Health ‚Üí {2} Cleanup{3}',
            needs.deploy.outputs.deploy_status == 'success' && '‚úÖ' || '‚ùå',
            needs.deploy.outputs.health_status == 'success' && '‚úÖ' || needs.deploy.outputs.health_status == 'skipped' && '‚è≠Ô∏è' || '‚ùå',
            needs.deploy.outputs.cleanup_status == 'success' && '‚úÖ' || needs.deploy.outputs.cleanup_status == 'skipped' && '‚è≠Ô∏è' || '‚ùå',
            needs.deploy.outputs.rollback_status != 'skipped' && format(' ‚Üí {0} Rollback{1}',
            needs.deploy.outputs.rollback_status == 'success' && '‚úÖ' || '‚ùå',
            needs.deploy.outputs.rollback_health_status == 'success' && ' ‚Üí ‚úÖ Verify' ||
            needs.deploy.outputs.rollback_health_status == 'failure' && ' ‚Üí ‚ùå Verify' || '') || '') || '' }}

            ${{ github.event_name == 'workflow_dispatch' && 'üîß **Triggered manually**' || format('üìù **Commit:** [`{0}`](https://github.com/{1}/commit/{2}) {3}', steps.commit-msg.outputs.short-sha, github.repository, inputs.target-ref, steps.commit-msg.outputs.message) }}

            **‚è±Ô∏è Duration:** ${{ github.event_name != 'workflow_dispatch' && '3min' || 'Manual' }}
          color: ${{ needs.deploy.result == 'success' && needs.deploy.outputs.deployment_needed == 'false' && 0x6c757d ||
            needs.deploy.outputs.deploy_status == 'success' && needs.deploy.outputs.health_status == 'success' && 0x28a745 ||
            needs.deploy.outputs.rollback_status == 'success' && 0xffc107 ||
            needs.deploy.outputs.degraded_stacks != '' && 0xfd7e14 || 0xdc3545 }}
          username: "Compose Deploy"
          avatar_url: "https://cdn-icons-png.flaticon.com/512/919/919853.png"

      - name: Unload Discord webhook
        uses: 1password/load-secrets-action@8d0d610af187e78a2772c2d18d627f4c52d3fbfb  # v3.1.0
        with:
          unset-previous: true
