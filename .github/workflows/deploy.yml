name: Deploy Docker Compose

on:
  workflow_call:
    inputs:
      args:
        description: "docker compose up -d arguments"
        required: false
        type: string
      stacks:
        description: "JSON array of stack names to deploy"
        required: true
        type: string
      webhook-url:
        description: "1Password reference to Discord webhook URL"
        required: true
        type: string
      repo-name:
        description: "Repository display name for notifications"
        required: true
        type: string
      target-ref:
        description: "Git reference to checkout on remote server"
        required: true
        type: string
      has-dockge:
        description: "Whether this deployment includes Dockge"
        required: false
        type: boolean
        default: false

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    timeout-minutes: 40
    outputs:
      previous_sha: ${{ steps.backup.outputs.previous_sha }}
      deploy_status: ${{ steps.deploy.outcome }}
      health_status: ${{ steps.health.outcome }}
      cleanup_status: ${{ steps.cleanup.outcome }}
      rollback_status: ${{ steps.rollback.outcome }}
      healthy_stacks: ${{ steps.health.outputs.healthy_stacks }}
      degraded_stacks: ${{ steps.health.outputs.degraded_stacks }}
      failed_stacks: ${{ steps.health.outputs.failed_stacks }}
      total_containers: ${{ steps.health.outputs.total_containers }}
      running_containers: ${{ steps.health.outputs.running_containers }}
      success_rate: ${{ steps.health.outputs.success_rate }}
    steps:
      - name: Configure 1Password Service Account
        uses: 1password/load-secrets-action/configure@581a835fb51b8e7ec56b71cf2ffddd7e68bb25e0  # v2.0.0
        with:
          service-account-token: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}

      - name: Load Tailscale credentials
        id: load-tailscale-credentials
        uses: 1password/load-secrets-action@581a835fb51b8e7ec56b71cf2ffddd7e68bb25e0  # v2.0.0
        with:
          export-env: false
          unset-previous: true
        env:
          TAILSCALE_OAUTH_CLIENT_ID: "op://Docker/tailscale-oauth/client_id"
          TAILSCALE_OAUTH_SECRET: "op://Docker/tailscale-oauth/secret"

      - name: Connect to Tailnet
        uses: tailscale/github-action@84a3f23bb4d843bcf4da6cf824ec1be473daf4de  # v3.2.3
        with:
          oauth-client-id: ${{ steps.load-tailscale-credentials.outputs.TAILSCALE_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ steps.load-tailscale-credentials.outputs.TAILSCALE_OAUTH_SECRET }}
          tags: tag:ci
          use-cache: true
          version: latest

      - name: Unload Tailscale credentials
        uses: 1password/load-secrets-action@581a835fb51b8e7ec56b71cf2ffddd7e68bb25e0  # v2.0.0
        with:
          unset-previous: true

      - name: Store current deployment for rollback
        id: backup
        run: |
          echo "::group::Preparing deployment backup"
          ssh -o "StrictHostKeyChecking no" ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} "
            cd /opt/compose
            CURRENT_SHA=\$(git rev-parse HEAD)
            echo \"Current deployed SHA: \$CURRENT_SHA\"
            echo \"New deployment SHA: ${{ inputs.target-ref }}\"
          "
          echo "previous_sha=$(ssh -o 'StrictHostKeyChecking no' ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} 'cd /opt/compose && git rev-parse HEAD')" >> $GITHUB_OUTPUT
          echo "::endgroup::"

      - name: Deploy All Stacks
        id: deploy
        continue-on-error: true
        run: |
          echo "::group::Deploying all stacks"

          # Parse stacks from JSON input
          STACKS="${{ join(fromJson(inputs.stacks), ' ') }}"

          ssh -o "StrictHostKeyChecking no" ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} "
            set -e
            export OP_SERVICE_ACCOUNT_TOKEN=${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}

            ${{ inputs.has-dockge == true && format('
            echo \"ğŸš€ Deploying Dockge...\"
            cd /opt/dockge
            op run --env-file=/opt/compose/compose.env -- docker compose pull
            op run --env-file=/opt/compose/compose.env -- docker compose up -d --remove-orphans {0}
            echo \"âœ… Dockge deployed successfully\"
            ', inputs.args || '') || '' }}

            echo \"Updating repository to ${{ inputs.target-ref }}...\"
            git -C /opt/compose/ fetch
            git -C /opt/compose/ checkout ${{ inputs.target-ref }}

            # Function to deploy a single stack
            deploy_stack() {
              local STACK=\$1
              local LOGFILE=\"/tmp/deploy_\${STACK}.log\"
              {
                echo \"ğŸš€ Deploying \$STACK...\"
                cd /opt/compose/\$STACK

                echo \"  Pulling images for \$STACK...\"
                if ! op run --env-file=/opt/compose/compose.env -- docker compose pull; then
                  echo \"âŒ Failed to pull images for \$STACK\"
                  return 1
                fi

                echo \"  Starting services for \$STACK...\"
                if ! op run --env-file=/opt/compose/compose.env -- docker compose up -d --remove-orphans ${{ inputs.args || '' }}; then
                  echo \"âŒ Failed to start services for \$STACK\"
                  return 1
                fi

                echo \"âœ… \$STACK deployed successfully\"
                return 0
              } > \"\$LOGFILE\" 2>&1

              return \$?
            }

            # Start all deployments in parallel
            echo \"ğŸš€ Starting parallel deployment of all stacks...\"
            PIDS=\"\"

            # Deploy each stack in parallel
            for STACK in \$STACKS; do
              deploy_stack \"\$STACK\" &
              PIDS=\"\$PIDS \$!\"
              echo \"Started deployment of \$STACK (PID: \$!)\"
            done

            # Wait for all deployments and collect results
            echo \"â³ Waiting for all deployments to complete...\"
            FAILED_STACKS=\"\"

            # Wait for all background jobs
            wait

            # Check deployment results from log files
            for STACK in \$STACKS; do
              if [ -f \"/tmp/deploy_\${STACK}.log\" ]; then
                if grep -q \"âŒ.*\$STACK\" \"/tmp/deploy_\${STACK}.log\"; then
                  FAILED_STACKS=\"\$FAILED_STACKS \$STACK\"
                fi
              fi
            done

            # Display all deployment logs
            echo \"ğŸ“‹ Deployment Results:\"
            for STACK in \$STACKS; do
              if [ -f \"/tmp/deploy_\${STACK}.log\" ]; then
                echo \"--- \$STACK ---\"
                cat \"/tmp/deploy_\${STACK}.log\"
                rm -f \"/tmp/deploy_\${STACK}.log\"
              fi
            done

            # Check if any deployments failed
            if [ -n \"\$FAILED_STACKS\" ]; then
              echo \"ğŸ’¥ Deployments failed for:\$FAILED_STACKS\"
              exit 1
            fi

            echo \"ğŸ‰ All stacks deployed successfully in parallel!\"
          "
          echo "::endgroup::"

      - name: Health Check All Services
        id: health
        if: steps.deploy.outcome == 'success'
        continue-on-error: true
        run: |
          echo "::group::Health checking all services"

          # Parse stacks from JSON input
          STACKS="${{ join(fromJson(inputs.stacks), ' ') }}"

          ssh -o "StrictHostKeyChecking no" ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} "
            set -e
            export OP_SERVICE_ACCOUNT_TOKEN=${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}

            echo \"â³ Waiting for services to stabilize...\"
            sleep 15

            FAILED_STACKS=\"\"
            DEGRADED_STACKS=\"\"
            HEALTHY_STACKS=\"\"
            TOTAL_CONTAINERS=0
            RUNNING_CONTAINERS=0

            ${{ inputs.has-dockge == true && '
            echo \"ğŸ” Health checking Dockge...\"
            cd /opt/dockge
            DOCKGE_RUNNING=\$(op run --env-file=/opt/compose/compose.env -- docker compose ps --services --filter \"status=running\" | wc -l | tr -d \" \")
            DOCKGE_TOTAL=\$(op run --env-file=/opt/compose/compose.env -- docker compose ps --services | wc -l | tr -d \" \")
            TOTAL_CONTAINERS=\$((TOTAL_CONTAINERS + DOCKGE_TOTAL))
            RUNNING_CONTAINERS=\$((RUNNING_CONTAINERS + DOCKGE_RUNNING))
            
            if [ \"\$DOCKGE_RUNNING\" -eq 0 ]; then
              echo \"âŒ Dockge: 0/\$DOCKGE_TOTAL services running\"
              FAILED_STACKS=\"\$FAILED_STACKS dockge\"
            elif [ \"\$DOCKGE_RUNNING\" -lt \"\$DOCKGE_TOTAL\" ]; then
              echo \"âš ï¸ Dockge: \$DOCKGE_RUNNING/\$DOCKGE_TOTAL services running (degraded)\"
              DEGRADED_STACKS=\"\$DEGRADED_STACKS dockge\"
            else
              echo \"âœ… Dockge: All \$DOCKGE_RUNNING services healthy\"
              HEALTHY_STACKS=\"\$HEALTHY_STACKS dockge\"
            fi
            ' || '' }}

            # Function to perform comprehensive health check on a stack
            health_check_stack() {
              local STACK=\$1
              local LOGFILE=\"/tmp/health_\${STACK}.log\"
              {
                echo \"ğŸ” Health checking \$STACK...\"
                cd /opt/compose/\$STACK

                # Get container status information
                SERVICES_INFO=\$(op run --env-file=/opt/compose/compose.env -- docker compose ps --format json 2>/dev/null || echo '[]')
                RUNNING_COUNT=\$(echo \"\$SERVICES_INFO\" | jq -r 'length')
                TOTAL_COUNT=\$(op run --env-file=/opt/compose/compose.env -- docker compose config --services | wc -l | tr -d \" \")
                
                # Count healthy vs unhealthy containers
                HEALTHY_COUNT=\$(echo \"\$SERVICES_INFO\" | jq -r '[.[] | select(.State == \"running\")] | length' 2>/dev/null || echo \"0\")
                EXITED_COUNT=\$(echo \"\$SERVICES_INFO\" | jq -r '[.[] | select(.State == \"exited\")] | length' 2>/dev/null || echo \"0\")
                
                # Check for restart loops (containers that have restarted recently)
                RESTART_ISSUES=\$(echo \"\$SERVICES_INFO\" | jq -r '[.[] | select(.State == \"running\" and (.Status | contains(\"Restarting\")))] | length' 2>/dev/null || echo \"0\")

                # Resource usage check
                if [ \"\$HEALTHY_COUNT\" -gt 0 ]; then
                  CONTAINER_NAMES=\$(echo \"\$SERVICES_INFO\" | jq -r '.[] | select(.State == \"running\") | .Name' 2>/dev/null | tr '\n' ' ')
                  if [ -n \"\$CONTAINER_NAMES\" ]; then
                    RESOURCE_INFO=\$(docker stats --no-stream --format \"{{.Name}}: CPU {{.CPUPerc}}, Mem {{.MemUsage}}\" \$CONTAINER_NAMES 2>/dev/null | head -3)
                  fi
                fi

                # Determine stack health status
                if [ \"\$HEALTHY_COUNT\" -eq 0 ]; then
                  echo \"âŒ \$STACK: No services running (\$EXITED_COUNT exited)\"
                  [ -n \"\$RESOURCE_INFO\" ] && echo \"   Resources: \$RESOURCE_INFO\"
                  return 1
                elif [ \"\$HEALTHY_COUNT\" -lt \"\$TOTAL_COUNT\" ]; then
                  echo \"âš ï¸  \$STACK: \$HEALTHY_COUNT/\$TOTAL_COUNT services running\"
                  [ \"\$EXITED_COUNT\" -gt 0 ] && echo \"   \$EXITED_COUNT services exited\"
                  [ \"\$RESTART_ISSUES\" -gt 0 ] && echo \"   âš ï¸ \$RESTART_ISSUES services restarting\"
                  [ -n \"\$RESOURCE_INFO\" ] && echo \"   Resources: \$RESOURCE_INFO\"
                  return 2  # Degraded state
                else
                  echo \"âœ… \$STACK: All \$HEALTHY_COUNT services healthy\"
                  [ \"\$RESTART_ISSUES\" -gt 0 ] && echo \"   âš ï¸ \$RESTART_ISSUES services had recent restarts\"
                  [ -n \"\$RESOURCE_INFO\" ] && echo \"   Resources: \$RESOURCE_INFO\"
                  return 0
                fi
              } > \"\$LOGFILE\" 2>&1

              return \$?
            }

            # Start all health checks in parallel
            echo \"ğŸ” Starting comprehensive health checks...\"
            HEALTH_PIDS=\"\"
            declare -A HEALTH_RESULTS

            # Health check each stack in parallel
            for STACK in \$STACKS; do
              health_check_stack \"\$STACK\" &
              PID=\$!
              HEALTH_PIDS=\"\$HEALTH_PIDS \$PID\"
              HEALTH_RESULTS[\$PID]=\$STACK
              echo \"Started health check for \$STACK (PID: \$PID)\"
            done

            # Wait for all health checks and collect results
            echo \"â³ Waiting for health checks to complete...\"
            for PID in \$HEALTH_PIDS; do
              wait \$PID
              EXIT_CODE=\$?
              STACK=\${HEALTH_RESULTS[\$PID]}
              
              case \$EXIT_CODE in
                0) HEALTHY_STACKS=\"\$HEALTHY_STACKS \$STACK\" ;;
                1) FAILED_STACKS=\"\$FAILED_STACKS \$STACK\" ;;
                2) DEGRADED_STACKS=\"\$DEGRADED_STACKS \$STACK\" ;;
              esac
            done

            # Calculate container statistics
            for STACK in \$STACKS; do
              if [ -f \"/tmp/health_\${STACK}.log\" ]; then
                STACK_CONTAINERS=\$(cd /opt/compose/\$STACK && op run --env-file=/opt/compose/compose.env -- docker compose config --services | wc -l | tr -d \" \")
                STACK_RUNNING=\$(cd /opt/compose/\$STACK && op run --env-file=/opt/compose/compose.env -- docker compose ps --services --filter \"status=running\" 2>/dev/null | wc -l | tr -d \" \" || echo \"0\")
                TOTAL_CONTAINERS=\$((TOTAL_CONTAINERS + STACK_CONTAINERS))
                RUNNING_CONTAINERS=\$((RUNNING_CONTAINERS + STACK_RUNNING))
              fi
            done

            # Display comprehensive health check results
            echo \"\"
            echo \"ğŸ“Š Health Check Summary:\"
            echo \"â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\"
            echo \"Total Services: \$TOTAL_CONTAINERS\"
            echo \"Running Services: \$RUNNING_CONTAINERS\"
            echo \"Success Rate: \$(( RUNNING_CONTAINERS * 100 / TOTAL_CONTAINERS ))%\"
            echo \"\"

            # Display results by category
            [ -n \"\$HEALTHY_STACKS\" ] && echo \"âœ… Healthy Stacks: \$(echo \$HEALTHY_STACKS | tr ' ' ',' | sed 's/^,//')\"
            [ -n \"\$DEGRADED_STACKS\" ] && echo \"âš ï¸ Degraded Stacks: \$(echo \$DEGRADED_STACKS | tr ' ' ',' | sed 's/^,//')\"
            [ -n \"\$FAILED_STACKS\" ] && echo \"âŒ Failed Stacks: \$(echo \$FAILED_STACKS | tr ' ' ',' | sed 's/^,//')\"

            echo \"\"
            echo \"ğŸ“‹ Detailed Results:\"
            echo \"â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\"
            for STACK in \$(echo \"\$STACKS\" | tr ' ' '\n' | sort); do
              if [ -f \"/tmp/health_\${STACK}.log\" ]; then
                cat \"/tmp/health_\${STACK}.log\"
                rm -f \"/tmp/health_\${STACK}.log\"
              fi
            done

            # Export variables for output capture
            echo \"HEALTH_OUTPUT_HEALTHY=\$(echo \$HEALTHY_STACKS | tr ' ' ',' | sed 's/^,//')\"
            echo \"HEALTH_OUTPUT_DEGRADED=\$(echo \$DEGRADED_STACKS | tr ' ' ',' | sed 's/^,//')\"
            echo \"HEALTH_OUTPUT_FAILED=\$(echo \$FAILED_STACKS | tr ' ' ',' | sed 's/^,//')\"
            echo \"HEALTH_OUTPUT_TOTAL=\$TOTAL_CONTAINERS\"
            echo \"HEALTH_OUTPUT_RUNNING=\$RUNNING_CONTAINERS\"
            echo \"HEALTH_OUTPUT_SUCCESS_RATE=\$(( RUNNING_CONTAINERS * 100 / TOTAL_CONTAINERS ))\""

            # Determine final health status
            if [ -n \"\$FAILED_STACKS\" ]; then
              echo \"\"
              echo \"ğŸ’¥ Health check failed - some stacks are not running\"
              exit 1
            elif [ -n \"\$DEGRADED_STACKS\" ]; then
              echo \"\"
              echo \"âš ï¸ Health check passed with warnings - some services degraded\"
              exit 0
            else
              echo \"\"
              echo \"ğŸ‰ All services are fully healthy!\"
              exit 0
            fi
          " | tee /tmp/health_output.log
          
          # Extract health outputs for Discord notifications
          if grep -q "HEALTH_OUTPUT_" /tmp/health_output.log 2>/dev/null; then
            grep "HEALTH_OUTPUT_HEALTHY=" /tmp/health_output.log | cut -d'=' -f2 | head -1 | xargs -I {} echo "healthy_stacks={}" >> $GITHUB_OUTPUT
            grep "HEALTH_OUTPUT_DEGRADED=" /tmp/health_output.log | cut -d'=' -f2 | head -1 | xargs -I {} echo "degraded_stacks={}" >> $GITHUB_OUTPUT
            grep "HEALTH_OUTPUT_FAILED=" /tmp/health_output.log | cut -d'=' -f2 | head -1 | xargs -I {} echo "failed_stacks={}" >> $GITHUB_OUTPUT
            grep "HEALTH_OUTPUT_TOTAL=" /tmp/health_output.log | cut -d'=' -f2 | head -1 | xargs -I {} echo "total_containers={}" >> $GITHUB_OUTPUT
            grep "HEALTH_OUTPUT_RUNNING=" /tmp/health_output.log | cut -d'=' -f2 | head -1 | xargs -I {} echo "running_containers={}" >> $GITHUB_OUTPUT
            grep "HEALTH_OUTPUT_SUCCESS_RATE=" /tmp/health_output.log | cut -d'=' -f2 | head -1 | xargs -I {} echo "success_rate={}" >> $GITHUB_OUTPUT
          else
            # Fallback outputs if parsing fails
            echo "healthy_stacks=" >> $GITHUB_OUTPUT
            echo "degraded_stacks=" >> $GITHUB_OUTPUT
            echo "failed_stacks=" >> $GITHUB_OUTPUT
            echo "total_containers=0" >> $GITHUB_OUTPUT
            echo "running_containers=0" >> $GITHUB_OUTPUT
            echo "success_rate=0" >> $GITHUB_OUTPUT
          fi
          
          rm -f /tmp/health_output.log
          echo "::endgroup::"

      - name: Cleanup unused images
        id: cleanup
        if: steps.deploy.outcome == 'success' && steps.health.outcome == 'success'
        continue-on-error: true
        run: |
          echo "::group::Cleaning up unused Docker images"
          ssh -o "StrictHostKeyChecking no" ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} "
            echo \"ğŸ§¹ Cleaning up unused Docker images...\"
            docker image prune -af
            echo \"âœ… Cleanup completed\"
          "
          echo "::endgroup::"

      - name: Rollback to Previous Version
        id: rollback
        if: steps.deploy.outcome == 'failure' || steps.health.outcome == 'failure'
        continue-on-error: true
        run: |
          echo "::group::Rolling back to previous deployment"
          echo "ğŸ”„ **INITIATING ROLLBACK**"
          echo "Previous SHA: ${{ steps.backup.outputs.previous_sha }}"
          echo "Failed SHA: ${{ inputs.target-ref }}"

          # Parse stacks from JSON input
          STACKS="${{ join(fromJson(inputs.stacks), ' ') }}"

          ssh -o "StrictHostKeyChecking no" ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} "
            set -e
            export OP_SERVICE_ACCOUNT_TOKEN=${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}

            echo \"ğŸ”„ Rolling back to ${{ steps.backup.outputs.previous_sha }}...\"
            git -C /opt/compose/ checkout ${{ steps.backup.outputs.previous_sha }}

            for STACK in \$STACKS; do
              echo \"ğŸ”„ Rolling back \$STACK...\"
              cd /opt/compose/\$STACK

              if ! op run --env-file=/opt/compose/compose.env -- docker compose up -d --remove-orphans; then
                echo \"âŒ Failed to rollback \$STACK\"
              else
                echo \"âœ… \$STACK rolled back successfully\"
              fi
            done

            echo \"âœ… Rollback completed\"
          "
          echo "::endgroup::"

      - name: Report Deployment Status
        if: always()
        run: |
          echo "::group::Deployment Summary"

          # Parse stacks from JSON input and create display list
          STACK_LIST="${{ join(fromJson(inputs.stacks), ', ') }}"
          ${{ inputs.has-dockge == true && 'STACK_LIST="dockge, $STACK_LIST"' || '' }}

          if [ "${{ steps.deploy.outcome }}" == "success" ] && [ "${{ steps.health.outcome }}" == "success" ]; then
            echo "ğŸ‰ **DEPLOYMENT SUCCESSFUL**"
            echo "âœ… All stacks deployed and healthy"
            echo "ğŸ“‹ Deployed stacks: $STACK_LIST"
            echo "ğŸ”„ SHA: ${{ inputs.target-ref }}"
            if [ "${{ steps.cleanup.outcome }}" == "success" ]; then
              echo "ğŸ§¹ Cleanup completed successfully"
            fi
          else
            echo "ğŸ’¥ **DEPLOYMENT FAILED**"
            echo "âŒ Deploy status: ${{ steps.deploy.outcome }}"
            echo "âŒ Health check status: ${{ steps.health.outcome }}"
            if [ "${{ steps.rollback.outcome }}" == "success" ]; then
              echo "ğŸ”„ Rollback completed successfully"
            else
              echo "âŒ Rollback status: ${{ steps.rollback.outcome }}"
            fi
            exit 1
          fi
          echo "::endgroup::"

  notify:
    name: Discord Notification
    runs-on: ubuntu-latest
    needs: [deploy]
    if: always()
    steps:
      - name: Configure 1Password Service Account
        uses: 1password/load-secrets-action/configure@581a835fb51b8e7ec56b71cf2ffddd7e68bb25e0  # v2.0.0
        with:
          service-account-token: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}

      - name: Load Discord webhook
        id: op-load-discord
        uses: 1password/load-secrets-action@581a835fb51b8e7ec56b71cf2ffddd7e68bb25e0  # v2.0.0
        with:
          export-env: false
          unset-previous: true
        env:
          DISCORD_WEBHOOK: ${{ inputs.webhook-url }}

      - name: Send Discord notification
        uses: sarisia/actions-status-discord@5ddd3b114a98457dd80a39b2f00b6a998cd69008  # v1.15.3
        with:
          webhook: ${{ steps.op-load-discord.outputs.DISCORD_WEBHOOK }}
          status: ${{ needs.deploy.outputs.deploy_status == 'success' && needs.deploy.outputs.health_status == 'success' && 'success' || 'failure' }}
          title: "ğŸš€ ${{ inputs.repo-name }} Deployment"
          description: |
            ${{ needs.deploy.outputs.deploy_status == 'success' && needs.deploy.outputs.health_status == 'success' && 'âœ… **DEPLOYMENT SUCCESSFUL**' || needs.deploy.outputs.rollback_status == 'success' && 'ğŸ”„ **DEPLOYMENT FAILED - ROLLED BACK**' || 'âŒ **DEPLOYMENT FAILED**' }}

            **Services:** ${{ needs.deploy.outputs.running_containers || '?' }}/${{ needs.deploy.outputs.total_containers || '?' }} running (${{ needs.deploy.outputs.success_rate || '?' }}%)
            ${{ needs.deploy.outputs.healthy_stacks != '' && format('âœ… Healthy: {0}', needs.deploy.outputs.healthy_stacks) || '' }}${{ needs.deploy.outputs.degraded_stacks != '' && format('âš ï¸ Degraded: {0}', needs.deploy.outputs.degraded_stacks) || '' }}${{ needs.deploy.outputs.failed_stacks != '' && format('âŒ Failed: {0}', needs.deploy.outputs.failed_stacks) || '' }}

            **Pipeline:** Deploy ${{ needs.deploy.outputs.deploy_status == 'success' && 'âœ…' || 'âŒ' }} â†’ Health ${{ needs.deploy.outputs.health_status == 'success' && 'âœ…' || needs.deploy.outputs.health_status == 'skipped' && 'â­ï¸' || 'âŒ' }} â†’ Cleanup ${{ needs.deploy.outputs.cleanup_status == 'success' && 'âœ…' || needs.deploy.outputs.cleanup_status == 'skipped' && 'â­ï¸' || 'âŒ' }}${{ needs.deploy.outputs.rollback_status != 'skipped' && format(' â†’ Rollback {0}', needs.deploy.outputs.rollback_status == 'success' && 'âœ…' || 'âŒ') || '' }}

            ${{ github.event_name == 'workflow_dispatch' && 'ğŸ”§ **Manual Trigger**' || format('ğŸ“ **Commit:** `{0}`', inputs.target-ref) }}
          color: ${{ needs.deploy.outputs.deploy_status == 'success' && needs.deploy.outputs.health_status == 'success' && 0x00ff00 || needs.deploy.outputs.degraded_stacks != '' && 0xff9900 || 0xff0000 }}
          username: "GitHub Actions"
          avatar_url: "https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png"
